import io
import json
import os
import secrets
import shutil
import sys
from collections import defaultdict
from datetime import datetime
from functools import wraps
from urllib.parse import urljoin, urlparse

from flask import (
    abort,
    Flask,
    jsonify,
    redirect,
    render_template,
    request,
    session,
    send_from_directory,
    send_file,
    url_for,
)
from google_auth_oauthlib.flow import Flow
from google.oauth2 import id_token
from google.auth.transport import requests as google_requests
from werkzeug.utils import secure_filename

from photo_processor import PhotoProcessor


app = Flask(__name__)

# --- CONFIGURATION ---
OUTPUT_DIR = "output_albums"
app.secret_key = os.environ.get("FLASK_SECRET_KEY") or os.urandom(24)

GOOGLE_CLIENT_ID = os.environ.get("GOOGLE_CLIENT_ID")
GOOGLE_CLIENT_SECRET = os.environ.get("GOOGLE_CLIENT_SECRET")
GOOGLE_REDIRECT_URI = os.environ.get("GOOGLE_REDIRECT_URI")

missing_google_config = [
    name
    for name, value in [
        ("GOOGLE_CLIENT_ID", GOOGLE_CLIENT_ID),
        ("GOOGLE_CLIENT_SECRET", GOOGLE_CLIENT_SECRET),
        ("GOOGLE_REDIRECT_URI", GOOGLE_REDIRECT_URI),
    ]
    if not value
]

GOOGLE_AUTH_ENABLED = not missing_google_config
if not GOOGLE_AUTH_ENABLED:
    missing_csv = ", ".join(missing_google_config)
    print(
        "Warning: Google sign-in disabled; missing configuration values: "
        f"{missing_csv}. Users may continue without authentication."
    )

AUTH_SCOPES = ["openid", "email", "profile"]


def _build_flow():
    """Construct a Google OAuth flow instance with project credentials."""
    if not GOOGLE_AUTH_ENABLED:
        raise RuntimeError("Google OAuth flow requested but configuration is missing.")
    return Flow.from_client_config(
        {
            "web": {
                "client_id": GOOGLE_CLIENT_ID,
                "client_secret": GOOGLE_CLIENT_SECRET,
                "auth_uri": "https://accounts.google.com/o/oauth2/auth",
                "token_uri": "https://oauth2.googleapis.com/token",
            }
        },
        scopes=AUTH_SCOPES,
        redirect_uri=GOOGLE_REDIRECT_URI,
    )


def _is_safe_redirect(target: str) -> bool:
    """Ensure redirects stay within this application."""
    if not target:
        return False
    host_url = request.host_url
    redirect_url = urljoin(host_url, target)
    return urlparse(redirect_url).netloc == urlparse(host_url).netloc


def _parse_iso_timestamp(value: str):
    """Parse ISO strings generated by the processor into datetime objects."""
    if not value:
        return None
    try:
        normalized = value.replace("Z", "+00:00")
        return datetime.fromisoformat(normalized)
    except ValueError:
        return None


def _format_day_label(dt: datetime):
    return dt.strftime("%B %d, %Y")


def _format_time_label(dt: datetime):
    return dt.strftime("%H:%M:%S")


def _allowed_photo_roots(faces_data):
    roots = {os.path.dirname(os.path.abspath(face["original_path"])) for face in faces_data if face.get("original_path")}
    roots.add(os.path.abspath(OUTPUT_DIR))
    return roots


def login_required(view=None, *, json_response=False):
    """Gate access to authenticated users, returning JSON when requested."""

    def decorator(func):
        @wraps(func)
        def wrapped_view(*args, **kwargs):
            if session.get("is_authenticated"):
                return func(*args, **kwargs)

            if json_response:
                return (
                    jsonify(
                        {"status": "error", "message": "Authentication required."}
                    ),
                    401,
                )

            if request.method == "GET":
                session["post_login_redirect"] = request.url
            return redirect(url_for("login"))

        return wrapped_view

    if view is None:
        return decorator
    return decorator(view)


@app.context_processor
def inject_user():
    """Expose signed-in user details to templates."""
    return {
        "google_user": session.get("google_user"),
        "is_authenticated": session.get("is_authenticated", False),
        "google_auth_enabled": GOOGLE_AUTH_ENABLED,
    }


# --- INITIALIZATION ---
print("Loading InsightFace model, this may take a moment...")
# Pass the output directory to the processor so it knows where to create the .cache
processor = PhotoProcessor(output_path_base=OUTPUT_DIR)
print("Model loaded successfully.")


# --- ROUTES ---
@app.route("/")
def index():
    """Serves the main page where the user provides the input folder."""
    return render_template("index.html")


@app.route("/search")
def search():
    """Serves the new page for searching for a specific person."""
    return render_template("search.html")


@app.route("/run_search", methods=["POST"])
def run_search():
    """Handles the search form submission."""
    sample_files = request.files.getlist("sample_files")
    search_path = request.form.get("search_path")
    album_name = request.form.get("album_name")

    if not all([sample_files, search_path, album_name]):
        return render_template(
            "search.html", status_message="Error: All fields are required."
        )

    if not os.path.isdir(search_path):
        return render_template(
            "search.html", status_message=f"Error: Search directory not found."
        )

    # Save sample files to a temporary location within the cache
    sample_paths = []
    temp_sample_dir = os.path.join(processor.cache_path, "temp_samples")
    os.makedirs(temp_sample_dir, exist_ok=True)
    for file in sample_files:
        if file.filename != "":
            filename = secure_filename(file.filename)
            filepath = os.path.join(temp_sample_dir, filename)
            file.save(filepath)
            sample_paths.append(filepath)

    if not sample_paths:
        return render_template(
            "search.html", status_message="Error: No valid sample files were uploaded."
        )

    # Capture print statements to show as a log
    old_stdout = sys.stdout
    sys.stdout = captured_output = io.StringIO()

    try:
        processor.search_for_person(sample_paths, search_path, album_name)
        status_message = captured_output.getvalue()
    except Exception as e:  # pylint: disable=broad-except
        status_message = f"An unexpected error occurred: {e}\n"
        status_message += captured_output.getvalue()
    finally:
        sys.stdout = old_stdout
        # Clean up temp sample files
        shutil.rmtree(temp_sample_dir)

    return render_template("search.html", status_message=status_message)


@app.route("/process", methods=["POST"])
def process():
    """
    Handles the initial processing request for cluster discovery.
    """
    folder_path = request.form.get("folder_path")

    if not folder_path or not os.path.isdir(folder_path):
        return render_template(
            "index.html", status_message="Error: Invalid folder path."
        )

    all_faces = processor.extract_faces(folder_path)
    if not all_faces:
        return render_template(
            "index.html",
            status_message="No faces found in the provided directory.",
        )

    labels = processor.cluster_faces(all_faces)
    cluster_data = processor.generate_cluster_ui_data(all_faces, labels)

    return render_template("gallery.html", clusters=cluster_data)


@app.route("/save_albums", methods=["POST"])
def save_albums():
    """
    Receives the corrected cluster data from the UI and saves the final albums.
    """
    corrected_clusters = request.json.get("clusters")

    try:
        with open(os.path.join(processor.cache_path, "all_faces_data.json"), "r") as f:
            all_faces_data = json.load(f)
    except FileNotFoundError:
        return (
            jsonify(
                {
                    "status": "error",
                    "message": "Cache data not found. Please re-process images.",
                }
            ),
            400,
        )

    PhotoProcessor.save_final_albums(corrected_clusters, all_faces_data, OUTPUT_DIR)

    # Keep cluster assignment names in sync with user edits
    assignments = processor.load_cluster_assignments()
    if assignments:
        assignments_by_id = {
            item["cluster_id"]: item for item in assignments if "cluster_id" in item
        }
        for cluster in corrected_clusters or []:
            cluster_id = cluster.get("cluster_id")
            if cluster_id in assignments_by_id:
                assignments_by_id[cluster_id]["name"] = cluster.get(
                    "name", assignments_by_id[cluster_id].get("name")
                )
        processor._persist_cluster_assignments(assignments_by_id)

    return jsonify({"status": "success", "message": "Albums saved successfully!"})


@app.route("/output_albums/.cache/faces/<path:filename>")
def serve_cached_faces(filename):
    """Serves the cropped face images from the cache directory."""
    return send_from_directory(processor.faces_cache_path, filename)


@app.route("/timeline")
def timeline_index():
    """List available clusters and provide entry points into their timelines."""
    assignments = processor.load_cluster_assignments()
    faces_data = processor.load_all_faces_data()
    face_map = {face["face_id"]: face for face in faces_data}

    clusters = []
    for cluster in assignments:
        face_ids = cluster.get("face_ids", [])
        originals = {
            os.path.abspath(face_map[fid]["original_path"])
            for fid in face_ids
            if fid in face_map and face_map[fid].get("original_path")
        }
        clusters.append(
            {
                "cluster_id": cluster["cluster_id"],
                "name": cluster.get("name") or f"Person {cluster['cluster_id'] + 1}",
                "photo_count": len(originals),
                "face_count": len(face_ids),
            }
        )

    clusters.sort(key=lambda c: (c["cluster_id"] == -1, c["name"].lower()))
    return render_template(
        "timeline_index.html",
        clusters=clusters,
        has_data=bool(clusters),
    )


@app.route("/timeline/<int:cluster_id>")
def timeline_detail(cluster_id):
    """Render a chronological gallery for a single cluster/person."""
    assignments = processor.load_cluster_assignments()
    cluster = next(
        (item for item in assignments if item.get("cluster_id") == cluster_id), None
    )
    if not cluster:
        abort(404)

    faces_data = processor.load_all_faces_data()
    face_map = {face["face_id"]: face for face in faces_data}

    photos_by_path = {}
    for face_id in cluster.get("face_ids", []):
        face = face_map.get(face_id)
        if not face:
            continue
        original_path = face.get("original_path")
        if not original_path:
            continue
        key = os.path.abspath(original_path)
        parsed_taken_at = _parse_iso_timestamp(face.get("taken_at"))
        existing = photos_by_path.get(key)
        if not existing:
            photos_by_path[key] = {
                "representative_face_id": face["face_id"],
                "original_path": original_path,
                "thumbnail_url": face.get("face_image_url"),
                "taken_at": face.get("taken_at"),
                "timestamp_source": face.get("timestamp_source") or "unknown",
                "parsed_taken_at": parsed_taken_at,
                "filename": os.path.basename(original_path),
            }
        else:
            current_dt = existing.get("parsed_taken_at")
            if (parsed_taken_at and not current_dt) or (
                parsed_taken_at and current_dt and parsed_taken_at < current_dt
            ):
                existing.update(
                    {
                        "representative_face_id": face["face_id"],
                        "taken_at": face.get("taken_at"),
                        "timestamp_source": face.get("timestamp_source") or "unknown",
                        "parsed_taken_at": parsed_taken_at,
                    }
                )

    photos = list(photos_by_path.values())
    if not photos:
        return render_template(
            "timeline_detail.html",
            cluster={
                "cluster_id": cluster_id,
                "name": cluster.get("name") or f"Cluster {cluster_id}",
            },
            timeline_groups=[],
            photo_count=0,
            date_range=None,
        )

    grouped = defaultdict(list)
    unknown_group = []
    timestamps = []

    for photo in photos:
        dt = photo.get("parsed_taken_at")
        if dt:
            grouped[dt.date()].append(photo)
            timestamps.append(dt)
        else:
            unknown_group.append(photo)

    timeline_groups = []
    for day in sorted(grouped.keys()):
        day_items = grouped[day]
        day_items.sort(
            key=lambda item: (
                item.get("parsed_taken_at"),
                item.get("filename"),
            )
        )
        label_dt = day_items[0]["parsed_taken_at"]
        timeline_groups.append(
            {
                "day_label": _format_day_label(label_dt),
                "items": [
                    {
                        "face_id": item["representative_face_id"],
                        "thumbnail_url": item["thumbnail_url"],
                        "original_url": url_for(
                            "serve_original_photo", face_id=item["representative_face_id"]
                        ),
                        "taken_at": item.get("taken_at"),
                        "time_label": _format_time_label(item["parsed_taken_at"]),
                        "timestamp_source": item.get("timestamp_source"),
                        "filename": item.get("filename"),
                    }
                    for item in day_items
                ],
            }
        )

    if unknown_group:
        unknown_group.sort(key=lambda item: item.get("filename"))
        timeline_groups.append(
            {
                "day_label": "Unknown Date",
                "items": [
                    {
                        "face_id": item["representative_face_id"],
                        "thumbnail_url": item["thumbnail_url"],
                        "original_url": url_for(
                            "serve_original_photo", face_id=item["representative_face_id"]
                        ),
                        "taken_at": item.get("taken_at"),
                        "time_label": "Unknown time",
                        "timestamp_source": item.get("timestamp_source"),
                        "filename": item.get("filename"),
                    }
                    for item in unknown_group
                ],
            }
        )

    date_range = None
    if timestamps:
        timestamps.sort()
        start_label = _format_day_label(timestamps[0])
        end_label = _format_day_label(timestamps[-1])
        if start_label == end_label:
            date_range = {"start": start_label, "end": None}
        else:
            date_range = {"start": start_label, "end": end_label}

    return render_template(
        "timeline_detail.html",
        cluster={
            "cluster_id": cluster_id,
            "name": cluster.get("name") or f"Cluster {cluster_id}",
        },
        timeline_groups=timeline_groups,
        photo_count=len(photos),
        date_range=date_range,
    )


@app.route("/timeline/photo/<int:face_id>")
def serve_original_photo(face_id):
    """Serve the original photo for a face if it resides in an allowed directory."""
    faces_data = processor.load_all_faces_data()
    face = next((item for item in faces_data if item.get("face_id") == face_id), None)
    if not face:
        abort(404)

    original_path = face.get("original_path")
    if not original_path:
        abort(404)

    real_path = os.path.realpath(original_path)
    allowed = False
    for root in _allowed_photo_roots(faces_data):
        abs_root = os.path.abspath(root)
        try:
            if os.path.commonpath([real_path, abs_root]) == abs_root:
                allowed = True
                break
        except ValueError:
            continue

    if not allowed:
        abort(403)

    if not os.path.isfile(real_path):
        abort(404)

    return send_file(real_path)


@app.route("/login")
def login():
    """Show the login screen or bounce authenticated users home."""
    if session.get("is_authenticated"):
        redirect_target = session.pop("post_login_redirect", None)
        if redirect_target and _is_safe_redirect(redirect_target):
            return redirect(redirect_target)
        return redirect(url_for("index"))

    next_param = request.args.get("next")
    if next_param and _is_safe_redirect(next_param):
        session["post_login_redirect"] = next_param

    error_message = session.pop("auth_error", None)
    return render_template(
        "login.html",
        error_message=error_message,
        google_auth_available=GOOGLE_AUTH_ENABLED,
    )


@app.route("/auth/google")
def auth_google():
    """Begin the Google OAuth flow."""
    if not GOOGLE_AUTH_ENABLED:
        abort(404)

    if session.get("is_authenticated"):
        return redirect(url_for("index"))

    flow = _build_flow()
    state = secrets.token_urlsafe(32)
    session["oauth_state"] = state

    authorization_url, _ = flow.authorization_url(
        prompt="select_account",
        include_granted_scopes="true",
        state=state,
    )
    return redirect(authorization_url)


@app.route("/auth/google/callback")
def auth_google_callback():
    """Handle the Google OAuth callback and establish a session."""
    if not GOOGLE_AUTH_ENABLED:
        abort(404)

    state = request.args.get("state")
    expected_state = session.get("oauth_state")
    if not state or state != expected_state:
        session["auth_error"] = (
            "We could not verify your login attempt. Please try again."
        )
        session.pop("oauth_state", None)
        return redirect(url_for("login"))

    flow = _build_flow()
    try:
        flow.fetch_token(authorization_response=request.url)
        credentials = flow.credentials
        id_info = id_token.verify_oauth2_token(
            credentials.id_token,
            google_requests.Request(),
            GOOGLE_CLIENT_ID,
        )
    except Exception as exc:  # pylint: disable=broad-except
        session["auth_error"] = f"Google sign-in failed: {exc}"
        session.pop("oauth_state", None)
        return redirect(url_for("login"))

    session["google_user"] = {
        "subject": id_info.get("sub"),
        "email": id_info.get("email"),
        "name": id_info.get("name"),
        "picture": id_info.get("picture"),
    }
    session["is_authenticated"] = True
    session.pop("oauth_state", None)

    redirect_target = session.pop("post_login_redirect", None)
    if redirect_target and _is_safe_redirect(redirect_target):
        return redirect(redirect_target)
    return redirect(url_for("index"))


@app.route("/logout")
def logout():
    """Clear the current session."""
    session.clear()
    if GOOGLE_AUTH_ENABLED:
        return redirect(url_for("login"))
    return redirect(url_for("index"))


# --- MAIN ---
if __name__ == "__main__":
    app.run(debug=True, host="0.0.0.0", port=8080)
